{"func": "\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() failes\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n", "comment": "\nFor the case of a variable which is referenced within a construct:\nobjects with dynamic storage duration should be shared.\nPutting it within a threadprivate directive may cause seg fault \nsince threadprivate copies are not allocated.\n\nDependence pair: *counter@73:7:W vs. *counter@73:7:W\n\n#pragma omp threadprivate(counter)", "idx": "DRB089"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf(\"a[1001]=%d\\n\", a[1001]);  \n  return 0;\n}\n\n", "comment": " \nA linear expression is used as array subscription.\nData race pair: a[2*i+1]@64:5:W vs. a[i]@64:14:R\n", "idx": "DRB033"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n\n  return 0;\n}\n\n", "comment": "\nA file-scope variable used within a function called by a parallel region.\nNo threadprivate is used to avoid data races.\n\nData race pairs  sum0@61:3:W vs. sum0@61:8:R\n                 sum0@61:3:W vs. sum0@61:3:W\n\n#pragma omp threadprivate(sum0)\n  reference calculation \n  assert(sum==sum1);", "idx": "DRB084"}
{"func": "\n\n\n\n#define N 100\n#define M 100 \n#define K 100\ndouble a[N][M],b[M][K],c[N][K];\n            \nint mmm()   \n{           \n  int i,j,k;\n#pragma omp parallel for private(j,k)\n  for (i = 0; i < N; i++) \n    for (k = 0; k < K; k++) \n      for (j = 0; j < M; j++)\n        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n  return 0; \n} \n\nint main()\n{\n  mmm();\n  return 0;\n}  \n", "comment": "\nClassic i-k-j matrix multiplication\n", "idx": "DRB060"}
{"func": "\n\n\n#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  \n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       \n      yy = (int) (-1.0 + dy * (j - 1));       \n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n", "comment": "\nUse of private() clause\n\n Initialize initial condition and RHS \n -1 < x < 1 \n -1 < y < 1 ", "idx": "DRB057"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n", "comment": " \n * Fibonacci code with data race (possible to scale problem size by providing\n * size argument).\n * Data Race Pair, i@25:5:W vs. i@29:7:R\n * ", "idx": "DRB177"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d\\n\", input, result);\n  assert (result==832040);\n  return 0;\n}\n", "comment": " This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task+taskwait. No data races.  \n * ", "idx": "DRB105"}
{"func": "\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/jacobi-2d-imper.h\"\n\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c2;\n    int c1;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c2;\n    int c1;\n    int c0;\n    for (c2 = 1; c2 <= 498; c2++) {\n      B[1][c2] = 0.2 * (A[1][c2] + A[1][c2 - 1] + A[1][1 + c2] + A[1 + 1][c2] + A[1 - 1][c2]);\n    }\n    for (c0 = 2; c0 <= 525; c0++) {\n      if (c0 <= 28) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + 1) * 3 < 0?-(-(2 * c0 + 1) / 3) : ((3 < 0?(-(2 * c0 + 1) + - 3 - 1) / - 3 : (2 * c0 + 1 + 3 - 1) / 3))); c2 <= (((2 * c0 + 1492) * 3 < 0?((3 < 0?-((-(2 * c0 + 1492) + 3 + 1) / 3) : -((-(2 * c0 + 1492) + 3 - 1) / 3))) : (2 * c0 + 1492) / 3)); c2++) {\n            B[1][(-2 * c0 + 3 * c2 + 2) / 3] = 0.2 * (A[1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1][(-2 * c0 + 3 * c2 + 2) / 3 - 1] + A[1][1 + (-2 * c0 + 3 * c2 + 2) / 3] + A[1 + 1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1 - 1][(-2 * c0 + 3 * c2 + 2) / 3]);\n          }\n        }\n      }\n#pragma omp parallel for private(c2)\n      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n        }\n        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n      }\n      if (c0 >= 499) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + -992) * 3 < 0?-(-(2 * c0 + -992) / 3) : ((3 < 0?(-(2 * c0 + -992) + - 3 - 1) / - 3 : (2 * c0 + -992 + 3 - 1) / 3))); c2 <= (((2 * c0 + 499) * 3 < 0?((3 < 0?-((-(2 * c0 + 499) + 3 + 1) / 3) : -((-(2 * c0 + 499) + 3 - 1) / 3))) : (2 * c0 + 499) / 3)); c2++) {\n            A[498][(-2 * c0 + 3 * c2 + 995) / 3] = B[498][(-2 * c0 + 3 * c2 + 995) / 3];\n          }\n        }\n      }\n    }\n    for (c2 = 20; c2 <= 517; c2++) {\n      A[498][c2 + -19] = B[498][c2 + -19];\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "comment": " Include polybench common header. \n Include benchmark-specific header. \n Default data type is double, default size is 20x1000. \n Array initialization. \nint i;\nint j;\n DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. \n Main computational kernel. The whole function will be timed,\n   including the call and return. \nint t;\nint i;\nint j;\n#pragma scop\n#pragma endscop\n Retrieve problem size. \n Variable declaration/allocation. \n Initialize array(s). \n Start timer. \n Run kernel. \n Stop and print timer. \n Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. \n Be clean. ", "idx": "DRB055"}
{"func": "\n\n\n#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n", "comment": "\nData race pair: a[i]@63:5:W vs. a[0]@63:15:R\n", "idx": "DRB040"}
{"func": "\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  \n  \n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "comment": "\nThis program is extracted from a real application at LLNL.\nTwo pointers (xa1 and xa2) have a pair of values with a distance of 12.\nThey are used as start base addresses for two 1-D arrays.\nTheir index set has two indices with distance of 12: 999 +12 = 1011.\nSo there is loop carried dependence.\n\nHowever, having loop carried dependence does not mean data races will always happen.\nThe iterations with loop carried dependence must be scheduled to\ndifferent threads in order for data races to happen.\n\nIn this example, we use schedule(static,1) to increase the chance that\nthe dependent loop iterations will be scheduled to different threads.\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n\n change original 921 to 923 = 911+12\n max index value is 2013. +12 to obtain a valid xa2[idx] after xa1+12.\n +1 to ensure a reference like base[2015] is within the bound.\n initialize segments touched by indexSet\n default static even scheduling may not trigger data race, using static,1 instead.", "idx": "DRB005"}
{"func": "\n\n\n\n#define num_steps 2000000000 \n\n#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf (\"PI=%f\\n\", pi);\n  return 0;\n}\n", "comment": "\nClassic PI calculation using reduction    \n", "idx": "DRB065"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <omp.h>\n#include <time.h>\n\n\n\n#define PATH -1\n#define NONE 0\n#define UP 1\n#define LEFT 2\n#define DIAGONAL 3\n\n\n\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n#define max(a,b) ((a) > (b) ? a : b)\n\n\n\n\n\n\nlong long int m ; \nlong long int n ;  \n\n\nint matchScore = 5;\nint missmatchScore = -3;\nint gapScore = -4;\n\n\nchar *a, *b;\n\n\nvoid generate() {\n    \n    srand(time(NULL));\n\n    \n    long long int i;\n    for (i = 0; i < m; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            a[i] = 'A';\n        else if (aux == 2)\n            a[i] = 'C';\n        else if (aux == 3)\n            a[i] = 'G';\n        else\n            a[i] = 'T';\n    }\n\n    \n    for (i = 0; i < n; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            b[i] = 'A';\n        else if (aux == 2)\n            b[i] = 'C';\n        else if (aux == 3)\n            b[i] = 'G';\n        else\n            b[i] = 'T';\n    }\n} \n\n\n\nlong long int nElement(long long int i) {\n    if (i < m && i < n) {\n        \n        return i;\n    }\n    else if (i < max(m, n)) {\n        \n        long long int min = min(m, n);\n        return min - 1;\n    }\n    else {\n        \n        long long int min = min(m, n);\n        return 2 * min - i + labs(m - n) - 2;\n    }\n}\n\n\nint matchMissmatchScore(long long int i, long long int j) {\n    if (a[j - 1] == b[i - 1])\n        return matchScore;\n    else\n        return missmatchScore;\n}  \n\n\nvoid similarityScore(long long int i, long long int j, int* H, int* P, long long int* maxPos) {\n\n    int up, left, diag;\n\n    \n    long long int index = m * i + j;\n\n    \n    up = H[index - m] + gapScore;\n\n    \n    left = H[index - 1] + gapScore;\n\n    \n    diag = H[index - m - 1] + matchMissmatchScore(i, j);\n\n    \n    int max = NONE;\n    int pred = NONE;\n    \n\n    if (diag > max) { \n        max = diag;\n        pred = DIAGONAL;\n    }\n\n    if (up > max) { \n        max = up;\n        pred = UP;\n    }\n\n    if (left > max) { \n        max = left;\n        pred = LEFT;\n    }\n    \n    H[index] = max;\n    P[index] = pred;\n\n    \n    if (max > H[*maxPos]) {        \n    #pragma omp critical\n        *maxPos = index;\n    }\n\n}  \n\n\nvoid calcFirstDiagElement(long long int *i, long long int *si, long long int *sj) {\n    \n    if (*i < n) {\n        *si = *i;\n        *sj = 1;\n    } else {\n        *si = n - 1;\n        *sj = *i - n + 2;\n    }\n}\n\n\nint main(int argc, char* argv[]) {\n    m = 2048;\n    n = 2048;\n\n#ifdef DEBUG\n    printf(\"\\nMatrix[%lld][%lld]\\n\", n, m);\n#endif\n\n    \n    a = malloc(m * sizeof(char));\n    b = malloc(n * sizeof(char));\n\n    \n    m++;\n    n++;\n\n    \n    int *H;\n    H = calloc(m * n, sizeof(int));\n\n    \n    int *P;\n    P = calloc(m * n, sizeof(int));\n\n\n    \n    generate();\n\n\n    \n    long long int maxPos = 0;\n    \n    long long int i, j;\n\n    \n    double initialTime = omp_get_wtime();\n\n    long long int si, sj, ai, aj;\n\n    \n    long long int nDiag = m + n - 3;\n    long long int nEle;\n\n    #pragma omp parallel \\\n    default(none) shared(H, P, maxPos, nDiag) private(nEle, i, si, sj, ai, aj)\n    {\n        for (i = 1; i <= nDiag; ++i)\n        {\n            nEle = nElement(i);\n            calcFirstDiagElement(&i, &si, &sj);\n            #pragma omp for\n            for (j = 1; j <= nEle; ++j)\n            {\n                ai = si - j + 1;\n                aj = sj + j - 1;\n                similarityScore(ai, aj, H, P, &maxPos);\n            }\n        }\n    }\n}\n", "comment": " \n   Data Race Pair, *maxPos@179:9:W vs. *maxPos@177:17:R\n                   H[index]@173:5:W vs. H[*maxPos]@177:15:W\n \n--------------------------------------------------------------------\n * Constants\n \n End of constants \n--------------------------------------------------------------------\n* Helpers\n\n #define DEBUG\n End of Helpers \n--------------------------------------------------------------------\n * Global Variables\n \nDefines size of strings to be compared\nColumns - Size of string a\nLines - Size of string b\nDefines scores\nStrings over the Alphabet Sigma\n End of global variables \nRandom seed\nGenerates the values of a\nGenerates the values of b\n End of generate \n--------------------------------------------------------------------\n * Function:    nElement\n * Purpose:     Calculate the number of i-diagonal elements\n \nNumber of elements in the diagonal is increasing\nNumber of elements in the diagonal is stable\nNumber of elements in the diagonal is decreasing\n--------------------------------------------------------------------\n * Function:    matchMissmatchScore\n * Purpose:     Similarity function on the alphabet for match/missmatch\n \n End of matchMissmatchScore \nStores index of element\nGet element above\nGet element on the left\nGet element on the diagonal\nCalculates the maximum\n === Matrix ===\n     *      a[0] ... a[n]\n     * b[0]\n     * ...\n     * b[n]\n     *\n     * generate 'a' from 'b', if '\u2190' insert e '\u2191' remove\n     * a=GAATTCA\n     * b=GACTT-A\n     *\n     * generate 'b' from 'a', if '\u2190' insert e '\u2191' remove\n     * b=GACTT-A\n     * a=GAATTCA\n    \nsame letter \u2196\nremove letter \u2191\ninsert letter \u2190\nInserts the value in the similarity and predecessor matrixes\nUpdates maximum score to be used as seed on backtrack\n End of similarityScore \n--------------------------------------------------------------------\n * Function:    calcElement\n * Purpose:     Calculate the position of (si, sj)-element\n \n Calculate the first element of diagonal\nAllocates a and b\nBecause now we have zeros\nAllocates similarity matrix H\nAllocates predecessor matrix P\nGen rand arrays a and b\nStart position for backtrack\nCalculates the similarity matrix\nGets Initial time\nBecause now we have zeros ((m-1) + (n-1) - 1)", "idx": "DRB181"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"expected %d real %d \\n\",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n", "comment": "\nVector addition followed by multiplication involving the same var should have a barrier in between.\nHere we have an implicit barrier after parallel for regions. No data race pair.\n", "idx": "DRB159"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          sleep(3);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf (\"result=%d\\n\", result);\n  assert (result==2);\n  return 0;\n}\n", "comment": " This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Use taskgroup to synchronize two tasks: \n * ", "idx": "DRB107"}
{"func": "\n\n#if (_OPENMP<201511)\n#error \"OpenMP 4.5 compilers (e.g. GCC 6.x or later ) are needed to compile this test.\"\n#endif\n\n#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  \n  for (i=0; i<MYLEN; i++)\n  {\n    \n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n", "comment": "\n * Cover the implicitly determined rule: In an orphaned task generating construct, \n * formal arguments passed by reference are firstprivate.\n * This requires OpenMP 4.5 to work. \n * Earlier OpenMP does not allow a reference type for a variable within firstprivate(). \n * \n correctness checking \nassert (a[i]==i+1);", "idx": "DRB100"}
{"func": "\n#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  \n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf (\"sum=%f sum2=%f\\n\", sum, sum2);\n  return 0;\n}\n", "comment": "\nuse of omp target + teams + distribute + parallel for\n\nInitialize with some values\n CPU reference computation ", "idx": "DRB097"}
{"func": "\n\n\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=0;j<m-1;j++) \n      b[i][j]=b[i][j+1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n", "comment": " \nOnly the outmost loop can be parallelized. \n  \n\n Be careful about bounds of j", "idx": "DRB063"}
{"func": "\n\n\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen(\"mytempfile.txt\",\"a+\");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,\"Error in fopen()\\n\");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, \"%d\\n\", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove(\"mytempfile.txt\");\n  if (ret != 0)\n  {\n    fprintf(stderr, \"Error: unable to delete mytempfile.txt\\n\");\n  }\n  return 0;\n}\n\n", "comment": "\n Example use of fprintf\n", "idx": "DRB049"}
{"func": "\n\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[0]=%d\\n\", output[0]);\n  return 0;\n}\n", "comment": " \nRace condition on outLen due to unprotected writes.\nAdding private (outLen) can avoid race condition. But it is wrong semantically.\n\nData race pairs: we allow two pair to preserve the original code pattern.\n1. outLen@72:12:W vs. outLen@72:12:W\n2. output[]@72:5:W vs. output[]@72:5:W\n", "idx": "DRB019"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "\nThe increment operation at line@27:7 is team specific as each team work on their individual var.\nNo Data Race Pair\n", "idx": "DRB145"}
{"func": "\n\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;\n}\n", "comment": " \ntmp should be annotated as private to avoid race condition.\nData race pairs: tmp@65:5:W vs. tmp@66:12:R\n                 tmp@65:5:W vs. tmp@65:5:W\n", "idx": "DRB028"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp task depend(in: x) if(0)                \n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                \n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n", "comment": "\n * There is no completion restraint on the second child task. Hence, immediately after the first\n * taskwait it is unsafe to access the y variable since the second child task may still be\n * executing.\n * Data Race at y@28:2:W vs. y@34:19:R\n\n1st Child Task\n 2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB131"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "This example is referred from DRACC by Adrian Schmitz et al.\nThe distribute parallel for directive at line 24 will execute loop using multiple teams.\nThe loop iterations are distributed across the teams in chunks in round robin fashion.\nThe missing lock enclosing var@26:5 leads to data race. Data Race Pairs, var@26:5:W vs. var@26:5:W\n", "idx": "DRB151"}
{"func": "\n\n\n\n#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n", "comment": "\nThis benchmark is extracted from flush_nolist.1c of OpenMP\nApplication Programming Interface Examples Version 4.5.0 .\n\nWe privatize variable i to fix data races in the original example.\nOnce i is privatized, flush is no longer needed.\n", "idx": "DRB076"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n", "comment": "\nA nested lock can be locked several times. It doesn't unlock until you have unset\nit as many times as the number of calls to omp_set_nest_lock.\nincr_b is called at line 48 and line 53. So, it needs a nest_lock enclosing line 32\nMissing nest_lock will lead to race condition at line:32.\nData Race Pairs, p->b@32:6:W vs. p->b@32:6:W\n", "idx": "DRB119"}
{"func": "\n#include <stdio.h>\n\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n", "comment": "\nTwo-dimensional array computation using loops: missing private(j).\nReferences to j in the loop cause data races.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@61:10, j@61:20}\n  Read_set = {j@62:20, j@62:12, j@61:14, j@61:20}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n", "idx": "DRB073"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n", "comment": " \n * Data race between non-sibling tasks with declared task dependency\n * Derived from code in https://hal.archives-ouvertes.fr/hal-02177469/document,\n * Listing 1.1\n * Data Race Pair, a@30:7:W vs. a@36:7:W\n * ", "idx": "DRB173"}
{"func": "\n\n\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=1;j<m;j++) \n      b[i][j]=b[i][j-1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n", "comment": " \nOnly the outmost loop can be parallelized. \n  \nThe inner loop has loop carried true data dependence.\nHowever, the loop is not parallelized so no race condition.\n\n Be careful about bounds of j", "idx": "DRB064"}
{"func": "\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf(\"%d %d\\n\",var,20*res);\n  return error;\n}\n", "comment": "\nNumber of threads is empirical: We need enough threads so that\nthe reduction is really performed hierarchically in the barrier!\nThere is no data race.\n", "idx": "DRB121"}
{"func": "\n\n\n#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n", "comment": "\nFreshly allocated pointers do not alias to each other.\n", "idx": "DRB066"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n", "comment": " \nThis program has data races due to true dependence within the loop at 63.\nData race pair: a[i+1]@64:5:W vs. a[i]@64:12:R\n", "idx": "DRB029"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=2, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n\n\n", "comment": " The safelen(2) clause safelen(2)@24:20 guarantees that the vector code is safe for vectors up to 2 (inclusive).\n * In the loop, m can be 2 or more for the correct execution. If the value of m is less than 2,\n * the behavior is undefined. No Data Race in b[i]@26:5 assignment.\n * ", "idx": "DRB137"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;      \n}\n\n", "comment": " \nLoop carried true dep between tmp =..  and ..= tmp.\nData race pair: tmp@66:12:R vs. tmp@67:5:W\n", "idx": "DRB035"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n", "comment": "\n * Taken from OpenMP Examples 5.0, example tasking.12.c\n * The created task will access different instances of the variable x if the task is not merged,\n * as x is firstprivate, but it will access the same variable x if the task is merged. It can\n * print two different values for x depending on the decisions taken by the implementation.\n * Data Race Pairs, x@27:5:W vs. x@27:5:W\n ", "idx": "DRB129"}
{"func": "\n\n\n\n#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n", "comment": " \nThis example is from DRACC by Adrian Schmitz et al.\nConcurrent access on a counter with no lock with simd. Atomicity Violation. Intra Region.\nData Race Pairs: var@33:7:W vs. var@33:7:W\n", "idx": "DRB161"}
{"func": "\n\n\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n}\n", "comment": " \nRace condition due to anti-dependence within a loop offloaded to accelerators.\nData race pair: a[i]@64:5:W vs. a[i+1]@64:10:R\n", "idx": "DRB026"}
{"func": "\n\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len], b[len];\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n#pragma omp simd\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]*b[i];\n  return 0;\n}\n", "comment": "\nThis one has race condition due to true dependence.\nBut data races happen at instruction level, not thread level.\nData race pair: a[i+1]@68:5:W vs. a[i]@68:12:R  \n", "idx": "DRB025"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n\n  return 0;\n}\n\n", "comment": "\nA file-scope variable used within a function called by a parallel region.\nNo threadprivate is used to avoid data races.\nThis is the case for a variable referenced within a construct. \n\nData race pairs  sum0@68:7:W vs. sum0@68:12:R\n                 sum0@68:7:W vs. sum0@68:7:W\n\n#pragma omp threadprivate(sum0)\n  reference calculation \n  assert(sum==sum1);", "idx": "DRB092"}
{"func": "\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf (\"numThreads=%d\\n\", numThreads);\n  return 0;\n}\n", "comment": "\nomp_get_thread_num() is used to ensure serial semantics.\n", "idx": "DRB051"}
{"func": "\n\n\n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n", "comment": "\nTwo tasks with depend clause to ensure execution order, no data races.\ni is shared for two tasks based on implicit data-sharing attribute rules.\n", "idx": "DRB078"}
{"func": "\n\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n", "comment": " \nTwo-dimensional array computation:\nTwo loops are associated with omp taskloop due to collapse(2).\nBoth loop index variables are private.\ntaskloop requires OpenMP 4.5 compilers.\n", "idx": "DRB096"}
{"func": "\n\n\nint main()\n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n\n  for(i=0;i<n; i++) \n    for(j=0;j<n; j++) \n      b[i][j]=(double)(i*j);\n\n  for (i=1;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n  return 0;\n}\n", "comment": "\nExample with loop-carried data dependence at the outer level loop.\nThe inner level loop can be parallelized.\n", "idx": "DRB054"}
{"func": "\n\n\n\n#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n", "comment": " \nReduction clause at line 27:39 will ensure there is no data race in var@31:7. No Dadta Race. \n", "idx": "DRB162"}
{"func": "\n\n\n#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf (\"a[500]=%d\\n\", a[500] );\n  return 0;\n} \n", "comment": "\nA loop with loop-carried anti-dependence.\nData race pair: a[i+1]@64:10:R vs. a[i]@64:5:W\n", "idx": "DRB001"}
{"func": "\n\n\n#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n", "comment": "\nTwo tasks with depend clause to ensure execution order:\ni is shared for two tasks based on implicit data-sharing attribute rules.\n", "idx": "DRB072"}
{"func": "\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/3mm.h\"\n\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  \n  \n{\n    int c3;\n    int c4;\n    int c1;\n    int c2;\n    if (ni >= ((0 > -1 * nj + -1 * nm + 1?0 : -1 * nj + -1 * nm + 1)) && nj >= 0 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) < (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16))?(((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) : (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) < nm + -1?((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) < nm + -1?((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nl + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nl + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) < nm + -1?((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= nk + -1; c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= nm + -1; c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= ((0 > -1 * nj + 1?0 : -1 * nj + 1)) && nj >= 0 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) < (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16))?(((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) : (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16)))); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + nm + -1) * 16 < 0?((16 < 0?-((-(ni + nm + -1) + 16 + 1) / 16) : -((-(ni + nm + -1) + 16 - 1) / 16))) : (ni + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n              A[c3][c4] = ((double )c3) * c4 / ni;\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) < (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16))?(((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) : (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n              B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk >= 0 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c5;\n    int c10;\n    int c2;\n    int c1;\n    int c6;\n    int c7;\n    if (ni >= 0 && nj >= 0 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + ni + -1) * 16 < 0?((16 < 0?-((-(nj + ni + -1) + 16 + 1) / 16) : -((-(nj + ni + -1) + 16 - 1) / 16))) : (nj + ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                G[c10][c7] = 0;\n              }\n            }\n          }\n          if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                F[c10][c7] = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n              F[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              G[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nl >= 1 && nm >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nm + -1?16 * c5 + 15 : nm + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                  F[c10][c7] += C[c10][c6] * D[c6][c7];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              E[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nk + -1?16 * c5 + 15 : nk + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  E[c10][c7] += A[c10][c6] * B[c6][c7];\n                }\n              }\n            }\n          }\n          for (c5 = 0; c5 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nl + -1?16 * c5 + 15 : nl + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  G[c10][c6] += E[c10][c7] * F[c7][c6];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n}\n\nint main(int argc,char **argv)\n{\n\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n\n  polybench_timer_start();\n  ;\n\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n", "comment": " Include polybench common header. \n Include benchmark-specific header. \n Default data type is double, default size is 4000. \n Array initialization. \nint i;\nint j;\n DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. \n Main computational kernel. The whole function will be timed,\n   including the call and return. \n int i;\n int j;\n int k;\n#pragma scop\n#pragma endscop\n Retrieve problem size. \n Variable declaration/allocation. \n Initialize array(s). \n Start timer. \n Run kernel. \n Stop and print timer. \n Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. \n Be clean. ", "idx": "DRB042"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              \n\n  #pragma omp taskwait depend(in: x)                                    \n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  \n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "comment": " The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. Therefore there is no race\n * condition.\n * \n 1st child task\n2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB167"}
{"func": "\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n", "comment": "\nThe restrict type qualifier is an indication to the compiler that,\nif the memory addressed by the restrict -qualified pointer is modified, no other pointer will access that same memory.\nIf a particular chunk of memory is not modified, it can be aliased through more than one restricted pointer.\nA C99 restrict feature.\nFor gcc, you must use -std=c99 to compile this program.\n", "idx": "DRB068"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[500]=%d\\n\",output[500]);\n\n  return 0;\n}\n", "comment": " Data race on outLen due to ++ operation.\nAdding private (outLen) can avoid race condition. But it is wrong semantically.\nData races on outLen also cause output[outLen++] to have data races.\n\nData race pairs (we allow two pairs to preserve the original code pattern):\n1. outLen@72:12:W vs. outLen@72:12:W\n2. output[]@72:5:W vs. output[]@72:5:W\n", "idx": "DRB018"}
{"func": "\n#include <stdio.h>\n\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf(\"b[50]=%f\\n\",b[50]);\n  return 0;\n}\n", "comment": "\nuse of omp target + map + array sections derived from pointers\n", "idx": "DRB099"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}\n", "comment": "This example is referred from DRACC by Adrian Schmitz et al.\nMissing ordered directive causes data race pairs var@28:5:W vs. var@28:13:R\n", "idx": "DRB156"}
{"func": "\n\n\n#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf (\"x=%f y=%d\\n\", x, y);\n  return 0;\n}\n", "comment": "\n *  threadprivate+copyprivate: no data races\n", "idx": "DRB102"}
{"func": "\n\n\n\n#include<stdio.h>\n\n\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf (\"i=%d\\n\",i);\n  return 0;   \n}\n", "comment": "\nA function arguments is passed by reference: \nits data-sharing attribute is the same as its actual argument's. \ni is shared. *q is shared.\nData race pair: *q@59:4:W vs. *q@59:4:W \n\n  argument pass-by-reference ", "idx": "DRB080"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "\nNo data race. The data environment of the task is created according to the\ndata-sharing attribute clauses, here at line 28 it is var. Hence, var is\nmodified 10 times, resulting to the value 10.\n", "idx": "DRB122"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n  }\n  }\n  return 0;\n}\n", "comment": " The explicit flush directive that provides at line:29 provides release semantics is needed\n * here to complete the synchronization. No data race.\n * ", "idx": "DRB143"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n", "comment": "\nTwo nested loops with loop-carried anti-dependence on the outer level.\nThis is a variable-length array version in C99.\nData race pair: a[i][j]@70:7:W vs. a[i+1][j]@70:18:R\n", "idx": "DRB004"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n", "comment": " To avoid data race, the initialization of the original list item \"a\" should complete before any\n * update of a as a result of the reduction clause. This can be achieved by adding an explicit\n * barrier after the assignment a=0@26:5, or by enclosing the assignment a=0@26:5 in a single directive\n * or by initializing a@21:7 before the start of the parallel region.\n * ", "idx": "DRB141"}
{"func": "\n\n\n\nvoid foo()\n{\n  static int q; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n", "comment": "\nA variable is declared inside a function called within a parallel region.\nThe variable should be shared if it uses static storage.\n\nData race pair: q@57:3:W vs. q@57:3:W \n", "idx": "DRB082"}
{"func": "\n\n\n#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n", "comment": "\nThis benchmark is extracted from flush_nolist.1c of OpenMP Application\nProgramming Interface Examples Version 4.5.0 .\nWe added one critical section to make it a test with only one pair of data races.\nThe data race will not generate wrong result though. So the assertion always passes.\nData race pair:  *q@60:3:W vs. i@71:11:R\n", "idx": "DRB074"}
{"func": "\n\n\nchar a[100];\nint main()\n{\n  int i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n", "comment": "\nOne dimension array computation\nwith finer granularity than traditional 4 bytes.\n\nDynamic tools monitoring 4-bytes elements may wrongfuly report race condition.\n", "idx": "DRB047"}
{"func": "\n\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n", "comment": " Addition of mutexinoutset dependence type on c, will ensure that line d@37:7 assignment will depend\n * on task at Line 32 and line 34. They might execute in any order but not at the same time.\n * There is no data race.\n * ", "idx": "DRB135"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n", "comment": "\nA loop with loop-carried anti-dependence.\nData race pair: a[i+1]@67:10:R vs. a[i]@67:5:W\n", "idx": "DRB002"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp taskwait depend(in: x)                  \n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                \n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n", "comment": "\n * There is no completion restraint on the second child task. Hence, immediately after the first\n * taskwait it is unsafe to access the y variable since the second child task may still be\n * executing.\n * Data Race at y@28:2:W vs. y@33:19:R\n\n1st Child Task\n 2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB165"}
{"func": "\n\n\n#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf(\"numThreads=%d\\n\", numThreads);\n    }\n  }\n  return 0;\n}\n", "comment": "\nTest if the semantics of omp_get_thread_num() is correctly recognized.\nThread with id 0 writes numThreads while other threads read it, causing data races.\nData race pair: numThreads@60:7:W vs. numThreads@64:33:R\n", "idx": "DRB075"}
{"func": "\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf (\"Number of Threads requested = %i\\n\",k);\n    }\n  }\n  return 0;\n}\n", "comment": "\nA master directive is used to protect memory accesses.\n", "idx": "DRB103"}
{"func": "\n\n\n\n#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d\",x);    \n  return 0;\n} \n\n", "comment": " \nThe loop in this example cannot be parallelized.\n\nThis pattern has two pair of dependencies:  \n1. loop carried output dependence\n x = .. : \n\n2. loop carried true dependence due to: \n.. = x;\n x = ..; \nData race pairs: we allow two pairs to preserve the original code pattern.\n 1. x@73:12:R vs. x@74:5:W \n 2. x@74:5:W vs. x@74:5:W\n", "idx": "DRB016"}
{"func": "\n\n\nvoid foo1(double o1[], double c[], int len)\n{ \n  int i ;\n#pragma omp parallel for\n  for (i = 0; i < len; ++i) {\n    double volnew_o8 = 0.5 * c[i];\n    o1[i] = volnew_o8;\n  } \n}\n\ndouble o1[100];\ndouble c[100];\nint main()\n{\n  foo1 (o1, c, 100);\n  return 0;\n}\n", "comment": " \nArrays passed as function parameters\n", "idx": "DRB050"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp taskwait depend(in: x)                  \n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                \n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "comment": " The second taskwait ensures that the second child task has completed; hence it is safe to access\n * the y variable in the following print statement.\n * \n1st Child Task\n 2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB166"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf(\"a[500]=%d\\n\", a[500]);\n  return 0;\n}\n", "comment": "\nData race pair: a[i]@62:5:W vs. a[0]@62:15:R\n", "idx": "DRB039"}
{"func": "\n\n\n#define N 1000\ndouble a[N][N],v[N],v_out[N];\n\nvoid mv()\n{           \n  int i,j;\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n#pragma omp parallel for reduction(+:sum)\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n", "comment": "\nMatrix-vector multiplication: inner level parallelization.\n", "idx": "DRB062"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n", "comment": "\nA file-scope variable used within a function called by a parallel region.\nUse threadprivate to avoid data races.\n\n  reference calculation ", "idx": "DRB085"}
{"func": "\n#include <stdio.h>\n\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n", "comment": "\n *  loop missing the linear clause\n *  Data race pairs (race on j allows wrong indexing of c):  \n     j@70:7:R vs. j@71:5:W\n     j@71:5:W vs. j@71:5:W \n     c[j]@70:5:W vs. c[j]@70:5:W\n", "idx": "DRB111"}
{"func": "\n\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf (\"sum = %f\\n\", sum);  \n  return 0;\n}\n", "comment": "\nA kernel with two level parallelizable loop with reduction:\nif reduction(+:sum) is missing, there is race condition.\nData race pairs: we allow multiple pairs to preserve the pattern.\n  sum@70:7:W vs. sum@70:7:W\n  sum@70:7:W vs. sum@70:13:R\n", "idx": "DRB021"}
{"func": "\n\n\nint a[100], b[100], c[100];\nint main()\n{\n  int i;\n#pragma omp simd\n  for (i=0;i<100;i++)\n    a[i]=b[i]*c[i];\n  return 0;\n}\n", "comment": "\nOne dimension array computation with a vetorization directive\n", "idx": "DRB070"}
{"func": "\n\n\n#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n", "comment": " \nThe -- operation is not protected, causing race condition.\nData race pair: numNodes2@74:7:W vs. numNodes2@74:7:W\n", "idx": "DRB012"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long num_sz;\n\nint max_num_blocks;\nint num_refine;\nint num_vars;\nint x_block_size, y_block_size, z_block_size;\nint error_tol;\n\ndouble tol;\n\ntypedef struct {\n   num_sz number;\n   int level;\n   int refine;\n   int new_proc;\n   num_sz parent;       \n                     \n                     \n   double ****array;\n} block;\n\nblock *blocks;\n\nvoid stencil_calc(int var, int stencil_in)\n{\n   int i, j, k, in;\n   double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];\n   block *bp;\n\n   int tid;\n\n#pragma omp parallel default(shared) private(i, j, k, bp)\n  {\n      for (in = 0; in < max_num_blocks; ++in) {\n         bp = &blocks[in];\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n                                   bp->array[var][i  ][j-1][k  ] +\n                                   bp->array[var][i  ][j  ][k-1] +\n                                   bp->array[var][i  ][j  ][k  ] +\n                                   bp->array[var][i  ][j  ][k+1] +\n                                   bp->array[var][i  ][j+1][k  ] +\n                                   bp->array[var][i+1][j  ][k  ])/7.0;\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  bp->array[var][i][j][k] = work[i][j][k];\n      }\n  }\n}\n\n\nvoid allocate(void)\n{\n   int i, j, k, m, n;\n\n   blocks = (block *) malloc(max_num_blocks*sizeof(block));\n\n   for (n = 0; n < max_num_blocks; n++) {\n      blocks[n].number = -1;\n      blocks[n].array = (double ****) malloc(num_vars*sizeof(double ***));\n      for (m = 0; m < num_vars; m++) {\n         blocks[n].array[m] = (double ***)\n                              malloc((x_block_size+2)*sizeof(double **));\n         for (i = 0; i < x_block_size+2; i++) {\n            blocks[n].array[m][i] = (double **)\n                                   malloc((y_block_size+2)*sizeof(double *));\n            for (j = 0; j < y_block_size+2; j++)\n               blocks[n].array[m][i][j] = (double *)\n                                     malloc((z_block_size+2)*sizeof(double));\n         }\n      }\n   }\n}\n\nvoid deallocate(void)\n{\n   int i, j, m, n;\n\n   for (n = 0; n < max_num_blocks; n++) {\n      for (m = 0; m < num_vars; m++) {\n         for (i = 0; i < x_block_size+2; i++) {\n            for (j = 0; j < y_block_size+2; j++)\n               free(blocks[n].array[m][i][j]);\n            free(blocks[n].array[m][i]);\n         }\n         free(blocks[n].array[m]);\n      }\n      free(blocks[n].array);\n   }\n   free(blocks);\n}\n\nvoid init(void)\n{\n   int n, var, i, j, k, l, m, o, size, dir, i1, i2, j1, j2, k1, k2, ib, jb, kb;\n   num_sz num;\n   block *bp;\n\n\n   \n   \n   for (o = n = k1 = k = 0; k < 1; k++)\n      for (k2 = 0; k2 < 1; k1++, k2++)\n         for (j1 = j = 0; j < 1; j++)\n            for (j2 = 0; j2 < 1; j1++, j2++)\n               for (i1 = i = 0; i < 1; i++)\n                  for (i2 = 0; i2 < 1; i1++, i2++, n++) {\n                     bp = &blocks[o];\n                     bp->level = 0;\n                     bp->number = n;\n                     \n                     for (var = 0; var < num_vars; var++)\n                        for (ib = 1; ib <= x_block_size; ib++)\n                           for (jb = 1; jb <= y_block_size; jb++)\n                              for (kb = 1; kb <= z_block_size; kb++)\n                                 bp->array[var][ib][jb][kb] =\n                                    ((double) rand())/((double) RAND_MAX);\n                    o++;\n                  }\n}\n\n\n\nvoid driver(void)\n{\n  int start, number, var;\n\n  init();\n\n  for (var = 0; var < num_vars; var ++) {\n     stencil_calc(var, 7);\n  }\n}\n\n\nint main(int argc, char* argv[])\n{   \n  max_num_blocks = 500;\n  num_refine = 5;\n  num_vars = 40;\n  x_block_size = 10;\n  y_block_size = 10;\n  z_block_size = 10;\n\n  allocate();\n \n  driver();\n\n  deallocate();\n  return 0;\n} \n", "comment": "\n   Simplified miniAMR proxy app to reproduce data race behavior. \n   Data Race Pair, in@60:43:R vs. in@52:43:W\n                   work@65:19@W vs. work@65:19@W \n                   bp->array@65:36@R vs. bp->array@75:19@W \n                   bp->array@66:36@R vs. bp->array@75:19@W \n                   bp->array@67:36@R vs. bp->array@75:19@W \n                   bp->array@68:36@R vs. bp->array@75:19@W \n                   bp->array@69:36@R vs. bp->array@75:19@W \n                   bp->array@70:36@R vs. bp->array@75:19@W \n                   bp->array@71:36@R vs. bp->array@75:19@W \n \n if original block -1,\n else if on node, number in structure\n else (-2 - parent->number)\n Determine position of each core in initial mesh \n initialize\nadd_sorted_list(o, n, 0);", "idx": "DRB180"}
{"func": "\n#include <stdio.h>\n\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d (correct answer should be 55)\\n\", input, result);\n  return 0;\n}\n", "comment": " This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task but missing taskwait. \n * Data races pairs: i@61:5:W vs. i@65:14:R\n *                   j@63:5:W vs. j@65:16:R\n * \n We move the original taskwait to a location after i+j to \n * simulate the missing taskwait mistake.\n * Directly removing the taskwait may cause a child task to write to i or j\n * within the stack of a parent task which may already be gone, causing seg fault.\n * This change is suggested by Joachim Protze @RWTH-Aachen. \n * ", "idx": "DRB106"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n \",var);\n  return 0;\n}\n", "comment": "\nConcurrent accessing var@27:5 may cause atomicity violation and inter region data race.\nLock and reduction clause at line 24, avoids this. No Data Race Pair.\n", "idx": "DRB154"}
{"func": "\n\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n", "comment": " Due to the missing mutexinoutset dependence type on c, these tasks will execute in any\n * order leading to the data race at line 36. Data Race Pair, d@36:7:W vs. d@36:7:W\n * ", "idx": "DRB136"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n", "comment": " \n * Input dependence race: example from OMPRacer: A Scalable and Precise Static Race\n   Detector for OpenMP Programs\n * Data Race Pair, A[0]@45:7:W vs. A[i]@42:5:W\n * ", "idx": "DRB178"}
{"func": "\n\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n", "comment": " \nTwo-dimensional array computation:\nOnly one loop is associated with omp taskloop. \nThe inner loop's loop iteration variable will be shared if it is shared in the enclosing context.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@69:14, j@69:30, a[i][j]@70:11}\n  Read_set = {j@69:21, j@69:30, j@70:16, a[i][j]@70:11}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n", "idx": "DRB095"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              \n\n  #pragma omp task depend(in: x) if(0)                                  \n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  \n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "comment": " The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. Therefore there is no race\n * condition.\n * \n 1st child task\n2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB133"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n", "comment": " \nThe outer loop has a loop-carried true dependence.\nData race pair: b[i][j]@69:7:W vs. b[i-1][j-1]@69:15:R\n", "idx": "DRB032"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);\n  return 0;\n}\n\n", "comment": " \nOnly the outmost loop can be parallelized in this program.\nThe inner loop has true dependence.\nData race pair: b[i][j]@63:7:W vs. b[i][j-1]@63:15:R\n", "idx": "DRB037"}
{"func": "\n\n\n\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n", "comment": " \nTwo-dimensional array computation:\nOnly one loop is associated with the omp for construct. \nThe inner loop's loop iteration variable needs an explicit private() clause, \notherwise it will be shared by default. \n", "idx": "DRB046"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n", "comment": " The assignment to a@25:7 is  not synchronized with the update of a@29:11 as a result of the\n * reduction computation in the for loop.\n * Data Race pair: a@25:5:W vs. a@27:33:W\n * ", "idx": "DRB140"}
{"func": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n", "comment": "\nThis loop has loop-carried output-dependence due to x=... at line 63.\nThe problem can be solved by using lastprivate(x) .\nData race pair: x@63:5:W vs. x@63:5:W\n", "idx": "DRB010"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n", "comment": " \nThis program has data races due to true dependence within a loop.\nData race pair: a[i+1]@68:5:W vs. a[i]@68:12:R\n", "idx": "DRB030"}
{"func": "\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "comment": "\nTwo pointers have a distance of 12 (p1 - p2 = 12).\nThey are used as base addresses for indirect array accesses using an index set (another array).\n\nThe index set has two indices with a distance of 12 :\nindexSet[5]- indexSet[0] = 533 - 521 =  12\nSo there is loop carried dependence (e.g. between loops with index values of 0 and 5).\n\nWe use the default loop scheduling (static even) in OpenMP.\nIt is possible that two dependent iterations will be scheduled\nwithin a same chunk to a same thread. So there is no runtime data races.\n\nWhen N is 180, two iteraions with N=0 and N= 5 have loop carried dependences.\nFor static even scheduling, we must have at least 36 threads (180/36=5 iterations)\nso iteration 0 and 5 will be scheduled to two different threads.\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n\n 521+12=533\n initialize segments touched by indexSet\n default static even scheduling may not trigger data race!", "idx": "DRB006"}
{"func": "\n\n\n\n#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf (\"i=%d\\n\",i);\n  return 0;\n}\n\n", "comment": "\nA function argument passed by value should be private inside the function.\nVariable i is read only.\n\n  argument pass-by-value ", "idx": "DRB081"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n", "comment": "\n * Taken from OpenMP Examples 5.0, example tasking.12.c\n * x is a shared variable the outcome does not depend on whether or not the task is merged (that is,\n * the task will always increment the same variable and will always compute the same value for x).\n ", "idx": "DRB130"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n\n  return 0;\n}\n", "comment": "\nThis example is referred from DataRaceOnAccelerator : A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators.\nThough we have used critical directive to ensure that addition and subtraction are not overlapped,\ndue to different locks addlock@30:26 and sublock@33:26 interleave each others operation.\nData Race pairs, var@31:5:W vs. var@34:5:W\n", "idx": "DRB148"}
{"func": "\n\n\n\nint a[100][100];\nint b[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for default(none) shared(a) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n\n#pragma omp parallel for default(shared) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      b[i][j]=b[i][j]+1;\n\n  return 0;\n}\n\n", "comment": " \nTwo-dimensional array computation:\ndefault(none) to enforce explictly list all variables in data-sharing attribute clauses\ndefault(shared) to cover another option.\n", "idx": "DRB113"}
{"func": "\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/3mm.h\"\n\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  \n  \n{\n    int c2;\n    int c1;\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) < nm + -1?((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((((nk + -1 < nl + -1?nk + -1 : nl + -1)) < nm + -1?((nk + -1 < nl + -1?nk + -1 : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nm?nj : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nm?0 : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nk > nm?nk : nm); c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c1 <= ni + -1; c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nm?ni : nm); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c1 <= nk + -1; c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nj?0 : nj); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c1;\n    int c2;\n    int c5;\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        G[c1][c2] = 0;\n        F[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          F[c1][c2] += C[c1][c5] * D[c5][c2];\n        }\n      }\n    }\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        E[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          E[c1][c2] += A[c1][c5] * B[c5][c2];\n        }\n        for (c5 = 0; c5 <= 127; c5++) {\n          G[c1][c5] += E[c1][c2] * F[c2][c5];\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n\n  polybench_timer_start();\n  ;\n\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n", "comment": " Include polybench common header. \n Include benchmark-specific header. \n Default data type is double, default size is 4000. \n Array initialization. \nint i;\nint j;\n DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. \n Main computational kernel. The whole function will be timed,\n   including the call and return. \nint i;\nint j;\nint k;\n#pragma scop\n#pragma endscop\n Retrieve problem size. \n Variable declaration/allocation. \n Initialize array(s). \n Start timer. \n Run kernel. \n Stop and print timer. \n Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. \n Be clean. ", "idx": "DRB041"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"index: %d val: %d\\n\",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n", "comment": "This example is referred from DRACC by Adrian Schmitz et al.\nVector addition followed by multiplication involving the same var should have a barrier in between.\nomp distribute directive does not have implicit barrier. This will cause data race.\nData Race Pair: b[i]@42:19:R vs. b[i]@47:9:W\n", "idx": "DRB160"}
{"func": "\n\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n", "comment": "\n   omp for loop is allowed to use the linear clause, an OpenMP 4.5 addition.\n", "idx": "DRB112"}
{"func": "\n\n\n\nvoid foo()\n{\n  int q=0; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n", "comment": "\nA variable is declared inside a function called within a parallel region.\nThe variable should be private if it does not use static storage.\n\n", "idx": "DRB083"}
{"func": "\n\n\n#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf (\"j=%d k=%d\\n\", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n", "comment": "\ntasks with depend clauses to ensure execution order, no data races.\n", "idx": "DRB079"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  \n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n", "comment": "\nA file-scope variable used within a function called by a parallel region.\nUse threadprivate to avoid data races.\nThis is the case for a variable referenced within a construct.\n\n  reference calculation ", "idx": "DRB091"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n", "comment": " \n * Data race between non-sibling tasks with declared task dependency fixed by\n * adding a taskwait.\n * Derived from code in https://hal.archives-ouvertes.fr/hal-02177469/document,\n * Listing 1.2\n * No Data Race Pair\n * ", "idx": "DRB174"}
{"func": "\n\n\n\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nint main()\n{ \n  #pragma omp parallel \n  {\n   a.counter++; \n   a.pcounter++; \n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n", "comment": "\nFor the case of a variable which is referenced within a construct:\nstatic data member should be shared, unless it is within a threadprivate directive.\n\nDependence pair: a.counter@74:6:W vs. a.counter@74:6:W\n", "idx": "DRB087"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) \n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n", "comment": " \nThe outmost loop is be parallelized.\nBut the inner level loop has out of bound access for b[i][j] when j equals to 0.\nThis will case memory access of a previous row's last element.\n\nFor example, an array of 4x4: \n    j=0 1 2 3\n i=0  x x x x\n   1  x x x x\n   2  x x x x\n   3  x x x x\n   \n  outer loop: i=2, \n  inner loop: j=0\n  array element accessed b[i][j-1] becomes b[2][-1], which in turn is b[1][3]\n  due to linearized row-major storage of the 2-D array.\n\nThis causes loop-carried data dependence between i=2 and i=1.\nData race pair: b[i][j]@80:7:W vs. b[i][j-1]@80:15:R\n\n Note there will be out of bound access", "idx": "DRB015"}
{"func": "\n\n\n#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf (\"i=%d\\n\",i);\n  return 0;\n} \n", "comment": "\nTwo tasks without depend clause to protect data writes. \ni is shared for two tasks based on implicit data-sharing attribute rules.\nData race pair: i@61:5:W vs. i@63:5:W  \n", "idx": "DRB027"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n", "comment": "\nThis example is derived from an example by Simone Atzeni, NVIDIA.\n\nDescription: Race on variable init if used master construct. The variable is written by the\nmaster thread and concurrently read by the others.\n\nSolution: master construct does not have an implicit barrier better\nuse single at line 31. Fixed version for DRB124-master-orig-yes.c. No data race.\n", "idx": "DRB125"}
{"func": "\n\n \n\n\n#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n", "comment": "\n * The scheduling constraints prohibit a thread in the team from executing\n * a new task that modifies tp while another such task region tied to\n * the same thread is suspended. Therefore, the value written will\n * persist across the task scheduling point.\n * No Data Race at var@35:7\n ", "idx": "DRB128"}
{"func": "\n#include <stdio.h>\n\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n", "comment": " This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Missing the ordered clause\n * Data race pair: x@56:5:W vs. x@56:5:W\n * ", "idx": "DRB109"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=1, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n", "comment": " The safelen(2) clause at safelen(2)@24:20 guarantees that the vector code is safe for vectors\n * up to 2 (inclusive). In the loop, m@25:12 can be 2 or more for the correct execution. If the\n * value of m is less than 2, the behavior is undefined.\n * Data Race Pair: b[i]@26:5:W vs. b[i-m]@26:12:R\n * ", "idx": "DRB138"}
{"func": "\n\n\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for collapse(2)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n", "comment": " \nTwo-dimensional array computation: \ncollapse(2) is used to associate two loops with omp for. \nThe corresponding loop iteration variables are private. \n", "idx": "DRB093"}
{"func": "\n\n\n#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) \n      b[i][j]=b[i][j-1];\n\n  printf (\"b[50][50]=%f\\n\",b[50][50]);\n\n  return 0;     \n}\n  \n", "comment": " \nThe outmost loop is parallelized.\nBut the inner level loop has out of bound access for b[i][j] when j equals to 0.\nThis will case memory access of a previous row's last element.\n\nFor example, an array of 4x4: \n    j=0 1 2 3\n i=0  x x x x\n   1  x x x x\n   2  x x x x\n   3  x x x x\n  outer loop: i=2, \n  inner loop: j=0\n  array element accessed b[i][j-1] becomes b[2][-1], which in turn is b[1][3]\n  due to linearized row-major storage of the 2-D array.\n  This causes loop-carried data dependence between i=2 and i=1.\n\nData race pair: b[i][j]@75:7:W vs. b[i][j-1]@75:15:R\n\n Note there will be out of bound access", "idx": "DRB014"}
{"func": "\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() failes\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n", "comment": "\nFor the case of a variable which is not referenced within a construct:\nobjects with dynamic storage duration should be shared.\nPutting it within a threadprivate directive may cause seg fault since\n threadprivate copies are not allocated!\n\nDependence pair: *counter@63:6:W vs. *counter@63:6:W\n", "idx": "DRB088"}
{"func": "\n#include <stdio.h>\n\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  \n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf (\"a[50]=%f\\n\", a[50]);\n  return 0;\n}\n", "comment": "\nuse of omp target + teams \nWithout protection, master threads from two teams cause data races.\nData race pair: a@66:5:W vs. a@66:5:W\n\nInitialize with some values", "idx": "DRB116"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n  {\n#pragma omp task depend(inout : a) shared(a)\n    a++;\n  }\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n", "comment": " \n * Data race between non-sibling tasks created from different implicit tasks \n * with declared task dependency\n * Derived from code in https://hal.archives-ouvertes.fr/hal-02177469/document,\n * Listing 1.3\n * Data Race Pair, a@28:6:W vs. a@28:6:W\n * ", "idx": "DRB175"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf(\"%d\\n\",var[97]);\n\n  return 0;\n}\n", "comment": "\nThis kernel is modifie version from \u201cDataRaceOnAccelerator A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators\u201d by Adrian Schmitz et al.\nDue to distribute parallel for simd directive at line 31, there is a data race at line 33.\nData Rae Pairs, var@33:5:W vs. var@33:12:R\n.", "idx": "DRB157"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n", "comment": " \nA linear expression is used as array subscription.\nData race pair: a[2*i+1]@66:5:W vs. a[i]@66:14:R\n", "idx": "DRB034"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n  return 0;\n}\n", "comment": "\nThis kernel is referred from \u201cDataRaceOnAccelerator A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators\u201d by Adrian Schmitz et al.\nConcurrent access of var@28:5 in an intra region. Missing Lock leads to intra region data race.\nData Race pairs, var@28:5:W vs. var@28:5:W\n", "idx": "DRB153"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nstatic double x[20];\n#pragma omp threadprivate(x)\n\nint main(){\n  int i;\n  double j,k;\n\n  #pragma omp parallel for default(shared)\n  for (i = 0; i < 20; i++){\n    x[i] = -1.0;\n    if(omp_get_thread_num()==0){\n      j = x[0];\n    }\n    if(omp_get_thread_num()==0){\n      k = i+0.05;\n    }\n  }\n\n  printf (\"%f %f\\n\", j, k);\n\n  return 0;\n}\n\n", "comment": " This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * There is no data race pairs, example of a threadprivate var and update by TID==0 only.\n ", "idx": "DRB171"}
{"func": "\n\n\n\n#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  \n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf (\"numNodes2 = %d\\n\", numNodes2);\n  return 0;\n} \n", "comment": " \nThe -- operation on numNodes2 is not protected, causing data race.\nData race pair: numNodes2@74:7:W vs. numNodes2@74:7:W\n\n initialize x[]", "idx": "DRB011"}
{"func": "\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": " This example is referred from OpenMP Application Programming Interface 5.0, example tasking.7.c\n * A task switch may occur at a task scheduling point. A single thread may execute both of the\n * task regions that modify tp. The parts of these task regions in which tp is modified may be\n * executed in any order so the resulting value of var can be either 1 or 2.\n * There is a  Race pair var@34:7 and var@34:7 but no data race. \n ", "idx": "DRB127"}
{"func": "\n\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf(\"a[50]=%d\\n\",a[50]);\n  return 0;\n}\n", "comment": " \nThis one has data races due to true dependence. \nBut data races happen at both instruction and thread level. \nData race pair: a[i+1]@66:5:W vs. a[i]@66:12:R\n", "idx": "DRB115"}
{"func": "\n#include <stdio.h>\n\nint main()\n{\n  int len=100;\n  double a[len][len], b[len][len], c[len][len];\n  int i,j;\n\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n    {\n      a[i][j]=((double)i)/2.0; \n      b[i][j]=((double)i)/3.0; \n      c[i][j]=((double)i)/7.0; \n    }\n\n#pragma omp simd collapse(2)\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n      c[i][j]=a[i][j]*b[i][j];\n\n  printf (\"c[50][50]=%f\\n\",c[50][50]);\n  return 0;\n}\n", "comment": "\nTwo-dimension array computation with a vetorization directive\ncollapse(2) makes simd associate with 2 loops.\nLoop iteration variables should be predetermined as lastprivate. \n", "idx": "DRB098"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf(\"%d\\n\",var[63]);\n\n  return 0;\n}\n", "comment": "\nThis kernel is referred from \u201cDataRaceOnAccelerator A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators\u201d by Adrian Schmitz et al.\nConcurrent access of var@35:7 without acquiring locks causes atomicity violation. Data race present.\nData Race Pairs, var@35:7:W vs. var@35:7:W\n", "idx": "DRB164"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (i == 1) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n", "comment": " \n   Iteration 0 and 1 can have conflicting writes to A[0]. But if they are scheduled to be run by \n   the same thread, dynamic tools may miss this.\n   Data Race Pair, A[0]@34:7:W vs. A[i]@31:5:W\n ", "idx": "DRB179"}
{"func": "\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/adi.h\"\n\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    if (n >= 1) {\n#pragma omp parallel for private(c4, c2, c3)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c2;\n    int c8;\n    int c9;\n    int c15;\n    if (n >= 1 && tsteps >= 1) {\n      for (c0 = 0; c0 <= tsteps + -1; c0++) {\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n          }\n        }\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n          }\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *X, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_adi(tsteps,n, *X, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "comment": " Include polybench common header. \n Include benchmark-specific header. \n Default data type is double, default size is 10x1024x1024. \n Array initialization. \nint i;\nint j;\n DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. \n Main computational kernel. The whole function will be timed,\n   including the call and return. \nint t;\nint i1;\nint i2;\n#pragma scop\n#pragma endscop\n Retrieve problem size. \n Variable declaration/allocation. \n Initialize array(s). \n Start timer. \n Run kernel. \n Stop and print timer. \n Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. \n Be clean. ", "idx": "DRB044"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n    }\n  }\n  return 0;\n}\n", "comment": " The below program will fail to order the write to x on thread 0 before the read from x on thread 1.\n * The implicit release flush on exit from the critical region will not synchronize with the acquire\n * flush that occurs on the atomic read operation performed by thread 1. This is because implicit\n * release flushes that occur on a given construct may only synchronize with implicit acquire flushes\n * on a compatible construct (and vice-versa) that internally makes use of the same synchronization\n * variable.\n *\n * Implicit flush must be used after critical construct, after line:34 and before line:35 to avoid data race.\n * Data Race pair: x@34:9:W vs. x@34:9:W\n * ", "idx": "DRB142"}
{"func": "\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "\nThe distribute parallel for directive at line 27 will execute loop using multiple teams.\nThe loop iterations are distributed across the teams in chunks in round robin fashion.\nThe omp lock is only guaranteed for a contention group, i.e, within a team. Data Race Pair, var@30:5:W vs. var@30:5:W\n", "idx": "DRB150"}
{"func": "\n\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len;i++)\n    a[i]=a[i]+1;\n\n  return 0;\n}\n", "comment": "\nuse of omp target: len is not mapped. It should be firstprivate within target.\n", "idx": "DRB071"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n\n  return 0;\n}\n", "comment": "\nThe increment at line number 26 is critical for the variable\nvar@26:5. Therefore, there is a possible Data Race pair var@26:5:W vs. var@26:5:W\n", "idx": "DRB144"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n", "comment": " This example is modified version of nestable_lock.1.c example, OpenMP 5.0 Application Programming Examples.\nA nested lock can be locked several times. It doesn't unlock until you have unset\nit as many times as the number of calls to omp_set_nest_lock.\nincr_b is called at line 47 and line 52. So, it needs a nest_lock for p->b@30:4.\n", "idx": "DRB118"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n", "comment": " \nWhen if() evalutes to true, this program has data races due to true dependence within the loop at 65.\nData race pair: a[i+1]@66:5:W vs. a[i]@66:12:R\n", "idx": "DRB114"}
{"func": "\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "comment": "\nTwo pointers have distance of 12 (p1 - p2 = 12).\nThey are used as base addresses for indirect array accesses using an index set (another array).\n\nAn index set has two indices with distance of 12 :\nindexSet[3]- indexSet[0] = 533 - 521 =  12\nSo there is loop carried dependence for N=0 and N=3.\n\nWe use the default loop scheduling (static even) in OpenMP.\nIt is possible that two dependent iterations will be scheduled\nwithin a same chunk to a same thread. So there is no runtime data races.\n\nN is 180, two iteraions with N=0 and N= 3 have loop carried dependences.\nFor static even scheduling, we must have at least 60 threads (180/60=3 iterations)\nso iteration 0 and 3 will be scheduled to two different threads.\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n\n 521+12=533\n initialize segments touched by indexSet\n default static even scheduling may not trigger data race!", "idx": "DRB007"}
{"func": "\n\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  for (i=0;i<len;i++)\n    printf(\"i=%d a[%d]=%d\\n\",i,i,a[i]);\n  return 0;\n}\n", "comment": " \nThis one has data races due to true dependence.\nBut data races happen at instruction level, not thread level. \nData race pair: a[i+1]@66:5:W vs. a[i]@66:12:R\n", "idx": "DRB024"}
{"func": "\n\n\n#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n\n\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       \n      yy = (int) (-1.0 + dy * (j - 1));       \n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         \n  ay = 1.0 / (dy * dy);         \n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       \n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n\n\n\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           \n\n  printf (\"Total Number of Iterations:%d\\n\", k);\n  printf (\"Residual:%E\\n\", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n", "comment": "\nTwo parallel for loops within one single parallel region,\ncombined with private() and reduction().\n\n Initialize initial condition and RHS \n#pragma omp parallel for private(i,j,xx,yy)\n -1 < x < 1 \n -1 < y < 1 \n Initialize coefficients \n X-direction coef \n Y-direction coef \n Central coeff \n Copy new solution into old \n  omp end parallel \n Error check \n  End iteration loop ", "idx": "DRB058"}
{"func": "\n\n\n#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf (\"count= %d\\n\", count);\n  return 0;\n}\n", "comment": "\nA single directive is used to protect a write.\n", "idx": "DRB077"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n", "comment": " \nOnly the outmost loop can be parallelized in this program.\nData race pair: b[i][j]@65:7:W vs. b[i][j-1]@65:15:R\n", "idx": "DRB038"}
{"func": "\n\n\n#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  \n  for (i=0; i<MYLEN; i++)\n  {\n    \n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n", "comment": "\n * Cover an implicitly determined rule: In a task generating construct, \n * a variable without applicable rules is firstprivate.\n * \n correctness checking \nassert (a[i]==i+1);", "idx": "DRB101"}
{"func": "\n\n\n#define N 100\n\ndouble a[N][N],v[N],v_out[N];\nint mv()\n{           \n  int i,j;\n#pragma omp parallel for private (i,j)\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n  return 0; \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n\n", "comment": "\nMatrix-vector multiplication: outer-level loop parallelization\n", "idx": "DRB061"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n", "comment": "\nThis example is derived from an example by Simone Atzeni, NVIDIA.\n\nDescription: Race on variable init. The variable is written by the\nmaster thread and concurrently read by the others.\n\nSolution: master construct at line 31:17 does not have an implicit barrier better\nuse single. Data Race Pair, init@33:7:W vs. init@36:13:R\n", "idx": "DRB124"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf(\"%d\\n \",var);\n  return 0;\n}\n", "comment": "\nThe var@25:5 is atomic update. Hence, there is no data race pair.\n", "idx": "DRB146"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         \n\n  #pragma omp task depend(in: x) if(0)                             \n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         \n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "comment": " The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. If we access y before the\n * second taskwait, there is a race condition at line 28:2 and 34:18. Data Race Pair, y@28:2:W vs. y@34:19:R\n * \n 1st child task\n2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB134"}
{"func": "\n\n\n#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf(\"x=%d\",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n", "comment": "\nUsing lastprivate() to resolve an output dependence.\n\nSemantics of lastprivate (x):\ncauses the corresponding original list item to be updated after the end of the region.\nThe compiler/runtime copies the local value back to the shared one within the last iteration.\n", "idx": "DRB059"}
{"func": "\n\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",i);\n  return 0;\n}\n", "comment": "\n * Referred from worksharing_critical.1.c\n * A single thread executes the one and only section in the sections region, and executes the\n * critical region. The same thread encounters the nested parallel region, creates a new team\n * of threads, and becomes the master of the new team. One of the threads in the new team enters\n * the single region and increments i by 1. At the end of this example i is equal to 2.\n", "idx": "DRB139"}
{"func": "\n\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n", "comment": "\ntmp should be put as private to avoid race condition\nData race pair: tmp@65:5:W vs. tmp@66:12:R\n", "idx": "DRB020"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf(\"Data Race\\n\");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n", "comment": "\nData Race free matrix vector multiplication using target construct.\n", "idx": "DRB149"}
{"func": "\n\n\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);  \n  return 0;\n}\n", "comment": " \nThere is a loop-carried true dependence within the outer level loop.\nData race pair: b[i][j]@66:7:W vs. b[i-1][j-1]@66:15:R\n ", "idx": "DRB031"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int i;\n  double q[10], qq[10];\n\n  for (i = 0; i < 10; i++) qq[i] = (double)i;\n  for (i = 0; i < 10; i++) q[i] = (double)i;\n\n  #pragma omp parallel default(shared)\n  {\n    #pragma omp for private(i)\n    for (i = 0; i < 10; i++)\n      q[i] += qq[i];\n\n    #pragma omp critical\n    {\n      q[9] += 1.0;\n    }\n    #pragma omp barrier\n    #pragma omp single\n    {\n      q[9] = q[9] - 1.0;\n    }\n\n  } \n\n  for (i = 0; i < 10; i++)printf(\"%f %f\\n\",qq[i],q[i]);\n\n  return 0;\n}\n\n", "comment": " This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * The private(i) inline 27 and explicit barrier inline 35 will ensure synchronized behavior.\n * No Data Race Pairs.\n ", "idx": "DRB172"}
{"func": "\n\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf (\"sum = %f\\n\", sum); \n  return 0;\n}\n", "comment": " \nA kernel for two level parallelizable loop with reduction:\nif reduction(+:sum) is missing, there is race condition.\nData race pairs: \n  sum@72:7:W vs. sum@72:7:W \n  sum@72:7:W vs. sum@72:13:R\n", "idx": "DRB022"}
{"func": "\n\n\n\n#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n", "comment": "\nTwo tasks with a lock synchronization to ensure execution order.\n", "idx": "DRB069"}
{"func": "\n\n\n\n#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n", "comment": "\nThis example is extracted from a paper: \nMa etc. Symbolic Analysis of Concurrency Errors in OpenMP Programs, ICPP 2013\n\nSome threads may finish the for loop early and execute errors = dt[9]+1\nwhile another thread may still be simultaneously executing\nthe for worksharing region by writing to d[9], causing data races. \n\nData race pair: a[i]@72:7:W vs. a[9]@75:13:R\n", "idx": "DRB013"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "\nConcurrent access on same variable var@29 and var@32 leads to the race condition if two different\nlocks are used. This is the reason here we have used the atomic directive to ensure that addition\nand subtraction are not interleaved. No data race pairs.\n", "idx": "DRB147"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : i, j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n", "comment": " \n * Fibonacci code without data race\n * No Data Race Pair\n * ", "idx": "DRB176"}
{"func": "\n\n\n#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf (\"a[10][10]=%f\\n\", a[10][10]);\n  return 0;\n}\n\n", "comment": "\nA two-level loop nest with loop carried anti-dependence on the outer level.\nData race pair: a[i][j]@67:7:W vs. a[i+1][j]@67:18:R\n", "idx": "DRB003"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf(\"%d\\n\",var);\n  int error = (var != 2);\n  return error;\n}\n", "comment": "\nThe barrier construct specifies an explicit barrier at the point at which the construct appears.\nBarrier construct at line:27 ensures that there is no data race.\n", "idx": "DRB120"}
{"func": "\n\n\n#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n", "comment": "\nrestrict pointers: no aliasing\nArray initialization using assignments. \n\nC99 is needed to compile this code\ne.g. gcc -std=c99 -c Stress-1.c\n", "idx": "DRB067"}
{"func": "\n\n\n#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n", "comment": "\nExample with loop-carried data dependence at the outer level loop.\nBut the inner level loop can be parallelized.\n", "idx": "DRB053"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf(\"Data Race Detected\\n\");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n", "comment": "\nDepend clause at line 33 and 37 will ensure that there is no data race. There is an implicit barrier after tasks execution.\n", "idx": "DRB158"}
{"func": "\n\n\n#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n", "comment": "\nThis example is based on one code snippet extracted from a paper: \nMa etc. Symbolic Analysis of Concurrency Errors in OpenMP Programs, ICPP 2013\n\nExplicit barrier to counteract nowait\n", "idx": "DRB104"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp task depend(in: x) if(0)                \n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                \n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "comment": " The second taskwait ensures that the second child task has completed; hence it is safe to access\n * the y variable in the following print statement.\n * \n1st Child Task\n 2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB132"}
{"func": "\n\n\nint a[100];\nint main()\n{\nint i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n", "comment": " \nSimplest one dimension array computation\n", "idx": "DRB045"}
{"func": "\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/jacobi-2d-imper.h\"\n\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c2;\n    int c4;\n    int c3;\n    if (n >= 1) {\n#pragma omp parallel for private(c3, c4, c2)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c2; c3 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c4++) {\n              A[c4][c3] = (((double )c4) * (c3 + 2) + 2) / n;\n              B[c4][c3] = (((double )c4) * (c3 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    int c5;\n    if (n >= 3 && tsteps >= 1) {\n      for (c0 = 0; c0 <= (((n + 3 * tsteps + -4) * 16 < 0?((16 < 0?-((-(n + 3 * tsteps + -4) + 16 + 1) / 16) : -((-(n + 3 * tsteps + -4) + 16 - 1) / 16))) : (n + 3 * tsteps + -4) / 16)); c0++) {\n#pragma omp parallel for private(c5, c4, c2, c3)\n        for (c1 = (((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) > (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))?((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) : (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))); c1 <= (((((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) < c0?(((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) : c0)); c1++) {\n          for (c2 = ((((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) > 2 * c0 + -2 * c1?(((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) : 2 * c0 + -2 * c1); c2 <= (((((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) < (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16))?(((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) : (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16)))); c2++) {\n            if (c0 <= (((32 * c1 + 16 * c2 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 + 1) / 32) : -((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 - 1) / 32))) : (32 * c1 + 16 * c2 + -1 * n + 1) / 32)) && c1 <= c2 + -1) {\n              if ((n + 1) % 2 == 0) {\n                for (c4 = (16 * c1 > 16 * c2 + -1 * n + 3?16 * c1 : 16 * c2 + -1 * n + 3); c4 <= 16 * c1 + 15; c4++) {\n                  A[-16 * c2 + c4 + n + -2][n + -2] = B[-16 * c2 + c4 + n + -2][n + -2];\n                }\n              }\n            }\n            if (c0 <= (((48 * c1 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(48 * c1 + -1 * n + 1) + 32 + 1) / 32) : -((-(48 * c1 + -1 * n + 1) + 32 - 1) / 32))) : (48 * c1 + -1 * n + 1) / 32)) && c1 >= c2) {\n              if ((n + 1) % 2 == 0) {\n                for (c5 = (16 * c2 > 16 * c1 + -1 * n + 3?16 * c2 : 16 * c1 + -1 * n + 3); c5 <= ((16 * c1 < 16 * c2 + 15?16 * c1 : 16 * c2 + 15)); c5++) {\n                  A[n + -2][-16 * c1 + c5 + n + -2] = B[n + -2][-16 * c1 + c5 + n + -2];\n                }\n              }\n            }\n            for (c3 = ((((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) > 16 * c0 + -16 * c1?(((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) : 16 * c0 + -16 * c1); c3 <= ((((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) < 16 * c0 + -16 * c1 + 15?((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) : 16 * c0 + -16 * c1 + 15)); c3++) {\n              if (c1 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                for (c5 = (16 * c2 > 2 * c3 + 1?16 * c2 : 2 * c3 + 1); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[1][-2 * c3 + c5] = 0.2 * (A[1][-2 * c3 + c5] + A[1][-2 * c3 + c5 - 1] + A[1][1 + (-2 * c3 + c5)] + A[1 + 1][-2 * c3 + c5] + A[1 - 1][-2 * c3 + c5]);\n                }\n              }\n              for (c4 = (16 * c1 > 2 * c3 + 2?16 * c1 : 2 * c3 + 2); c4 <= ((16 * c1 + 15 < 2 * c3 + n + -2?16 * c1 + 15 : 2 * c3 + n + -2)); c4++) {\n                if (c2 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                  B[-2 * c3 + c4][1] = 0.2 * (A[-2 * c3 + c4][1] + A[-2 * c3 + c4][1 - 1] + A[-2 * c3 + c4][1 + 1] + A[1 + (-2 * c3 + c4)][1] + A[-2 * c3 + c4 - 1][1]);\n                }\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[-2 * c3 + c4][-2 * c3 + c5] = 0.2 * (A[-2 * c3 + c4][-2 * c3 + c5] + A[-2 * c3 + c4][-2 * c3 + c5 - 1] + A[-2 * c3 + c4][1 + (-2 * c3 + c5)] + A[1 + (-2 * c3 + c4)][-2 * c3 + c5] + A[-2 * c3 + c4 - 1][-2 * c3 + c5]);\n                  A[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1] = B[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1];\n                }\n                if (c2 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                  A[-2 * c3 + c4 + -1][n + -2] = B[-2 * c3 + c4 + -1][n + -2];\n                }\n              }\n              if (c1 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -1?16 * c2 + 15 : 2 * c3 + n + -1)); c5++) {\n                  A[n + -2][-2 * c3 + c5 + -1] = B[n + -2][-2 * c3 + c5 + -1];\n                }\n              }\n            }\n            if (c0 >= (((2 * c1 + c2 + -1) * 2 < 0?-(-(2 * c1 + c2 + -1) / 2) : ((2 < 0?(-(2 * c1 + c2 + -1) + - 2 - 1) / - 2 : (2 * c1 + c2 + -1 + 2 - 1) / 2)))) && c1 >= c2 + 1 && c2 <= (((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8))) {\n              for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < 16 * c2 + n + 12?16 * c1 + 15 : 16 * c2 + n + 12)); c4++) {\n                B[-16 * c2 + c4 + -14][1] = 0.2 * (A[-16 * c2 + c4 + -14][1] + A[-16 * c2 + c4 + -14][1 - 1] + A[-16 * c2 + c4 + -14][1 + 1] + A[1 + (-16 * c2 + c4 + -14)][1] + A[-16 * c2 + c4 + -14 - 1][1]);\n              }\n            }\n            if (c0 >= (((3 * c1 + -1) * 2 < 0?-(-(3 * c1 + -1) / 2) : ((2 < 0?(-(3 * c1 + -1) + - 2 - 1) / - 2 : (3 * c1 + -1 + 2 - 1) / 2)))) && c1 <= (((((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) < c2?(((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) : c2))) {\n              for (c5 = (16 * c2 > 16 * c1 + 15?16 * c2 : 16 * c1 + 15); c5 <= ((16 * c2 + 15 < 16 * c1 + n + 12?16 * c2 + 15 : 16 * c1 + n + 12)); c5++) {\n                B[1][-16 * c1 + c5 + -14] = 0.2 * (A[1][-16 * c1 + c5 + -14] + A[1][-16 * c1 + c5 + -14 - 1] + A[1][1 + (-16 * c1 + c5 + -14)] + A[1 + 1][-16 * c1 + c5 + -14] + A[1 - 1][-16 * c1 + c5 + -14]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "comment": " Include polybench common header. \n Include benchmark-specific header. \n Default data type is double, default size is 20x1000. \n Array initialization. \nint i;\nint j;\n DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. \n Main computational kernel. The whole function will be timed,\n   including the call and return. \nint t;\nint i;\nint j;\n#pragma scop\n#pragma endscop\n Retrieve problem size. \n Variable declaration/allocation. \n Initialize array(s). \n Start timer. \n Run kernel. \n Stop and print timer. \n Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. \n Be clean. ", "idx": "DRB056"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\n#define N 8\n\nint main()\n{\n  int i,j,k;\n  double r1[N], r[N][N][N];\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      for (k = 0; k < N; k++) {\n        r[i][j][k] = i;\n      }\n    }\n  }\n\n\n  #pragma omp parallel for default(shared) private(j,k)\n  for (i = 1; i < N-1; i++) {\n    for (j = 1; j < N-1; j++) {\n      for (k = 0; k < N; k++) {\n        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n      }\n    }\n  }\n\n  for (k = 0; k < N; k++) printf(\"%f \",r1[k]);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n", "comment": " This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * Due to missing construct to write r1[k]@38:9 synchronously, there is a Data Race.\n * Data Race Pair, r1[k]@38:9:W vs. r1[k]@38:9:W\n * ", "idx": "DRB169"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int i,j,k,m;\n  double tmp1;\n\n  double a[12][12][12];\n\n  m = 3.0;\n\n  #pragma omp parallel for private(j,k,tmp1)   \n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 12; j++) {\n      for (k = 0; k < 12; k++) {\n        tmp1 = 6.0/m;\n        a[i][j][k] = tmp1+4;\n      }\n    }\n  }\n\n  return 0;\n}\n\n", "comment": " This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * Use of private clause at 26:28 will ensure that there is no data race. No Data Race Pairs. \n ", "idx": "DRB170"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "\nA single thread will spawn all the tasks. Add if(0) to avoid the data race, undeferring the tasks.\n\nData Race pairs var@30:9:W vs. var@30:9:W\n", "idx": "DRB123"}
{"func": "\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "comment": "\nTwo pointers have a distance of 12 (xa2 - xa1 = 12).\nThey are used as base addresses for indirect array accesses using an index set (another array).\n\nThe index set has two indices with distance of 12 :\n   indexSet[1]- indexSet[0] = 533 - 521 =  12\nSo xa1[idx] and xa2[idx] may cause loop carried dependence for N=0 and N=3.\n\nWe use the default loop scheduling (static even) in OpenMP.\nIt is possible that two dependent iterations will be scheduled\nwithin a same chunk to a same thread. So there is no runtime data races.\n\nN is 180, two iteraions with N=0 and N= 1 have loop carried dependences.\nFor static even scheduling, we must have at least 180 threads (180/180=1 iterations)\nso iteration 0 and 1 will be scheduled to two different threads.\n\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n\n 521+12=533\n initialize segments touched by indexSet\n default static even scheduling may not trigger data race!", "idx": "DRB008"}
{"func": "\n#include <stdio.h>\n\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf (\"a=%d\\n\",a);\n  return 0;\n}\n\n", "comment": "\n * Test if atomic can be recognized properly. No data races.\n * ", "idx": "DRB108"}
{"func": "\n\n\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         \n\n  #pragma omp taskwait depend(in: x)                               \n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         \n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "comment": " The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. If we access y before the\n * second taskwait, there is a race condition at line 28 ann 33. Data Race Pair, y@28:2:W vs. y@33:19:R\n * \n 1st child task\n2nd child task\n 1st taskwait\n 2nd taskwait", "idx": "DRB168"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf(\"sum = %d\\n\", sum);\n  return 0;\n }\n", "comment": "\nThe thread encountering the taskwait directive at line 46 only waits for\nits child task (line 37-44) to complete. It does not wait for its\ndescendant tasks (line 39-42).\nData Race Pairs, sum@47:7:W vs. sum@47:7:W\n", "idx": "DRB117"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "comment": "\nConcurrent access of var@28:5 in an intra region. Lock ensures that there is no data race.\n", "idx": "DRB152"}
{"func": "\n\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n", "comment": "\nThis loop has loop-carried output-dependence due to x=... at line 59.\nThe problem can be solved by using lastprivate(x).\nData race pair: x@59:5:W vs. x@59:5:W\n", "idx": "DRB009"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf(\"%d\\n\",var[i]);\n    }\n  }\n\n  return 0;\n}\n", "comment": "\nConcurrent access of var@31:7 has no atomicity violation. No data race present.\n", "idx": "DRB163"}
{"func": "\n\n\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf (\"test i=%d j=%d\\n\",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n", "comment": " \nTwo-dimensional array computation: \nordered(2) is used to associate two loops with omp for.\nThe corresponding loop iteration variables are private. \n\nordered(n) is an OpenMP 4.5 addition. \n", "idx": "DRB094"}
{"func": "\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/adi.h\"\n\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c2;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c2;\n    int c8;\n    for (c0 = 0; c0 <= 9; c0++) {\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n      }\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *X, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_adi(tsteps,n, *X, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "comment": " Include polybench common header. \n Include benchmark-specific header. \n Default data type is double, default size is 10x1024x1024. \n Array initialization. \nint i;\nint j;\n DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. \n Main computational kernel. The whole function will be timed,\n   including the call and return. \nint t;\nint i1;\nint i2;\n#pragma scop\n#pragma endscop\n Retrieve problem size. \n Variable declaration/allocation. \n Initialize array(s). \n Start timer. \n Run kernel. \n Stop and print timer. \n Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. \n Be clean. ", "idx": "DRB043"}
{"func": "\n\n\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf(\"Error, malloc() returns NULL. End execution. \\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    \n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n", "comment": "\nThis example is to mimic a memory access pattern extracted from an LLNL proxy app.\nTwo pointers have distance of 12.\nThey are used as base addresses of two arrays, indexed through an index set.\nThe index set has no two indices with distance of 12.\nSo there is no loop carried dependence.\n\n this level of loop has no loop carried dependence\n verify the results, no overlapping of xa1 vs. xa2, no addition happens to the same element twice\nprintf (\"%f  \", base[i]);", "idx": "DRB052"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d, a[0]=%d\\n\",x,a[0]);    \n  return 0;\n} \n\n", "comment": "\nThe loop in this example cannot be parallelized.\n\nData race pairs: we allow two pairs to preserve the original code pattern.\n 1. x@71:12:R vs. x@72:5:W\n 2. x@72:5:W vs. x@72:5:W\n", "idx": "DRB017"}
{"func": "\n\n\n#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf(\"a[50]=%d b[50]=%d\\n\", a[50], b[50]);\n \n  return 0;\n}\n", "comment": "\nFor a variable declared in a scope inside an OpenMP construct:\n* private if the variable has an automatic storage duration\n* shared if the variable has a static storage duration. \n\nDependence pairs: \n   tmp@73:7:W vs. tmp@73:7:W\n   tmp@73:7:W vs. tmp@74:14:R\n\n static storage for a local variable \n automatic storage for a local variable ", "idx": "DRB090"}
{"func": "\n\n\n\nvoid foo(int * a, int n, int g)\n{\n  int i;\n#pragma omp parallel for firstprivate (g)\n  for (i=0;i<n;i++)\n  {\n    a[i] = a[i]+g;\n  }\n}\n\nint a[100];\nint main()\n{\n  foo(a, 100, 7);\n  return 0;\n}  \n", "comment": "\nExample use of firstprivate()\n", "idx": "DRB048"}
{"func": "\n\n\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n", "comment": "  \nLoop carried true dep between tmp =..  and ..= tmp.\nData race pairs: tmp@66:12:R vs. tmp@67:5:W\n                 tmp@67:5:W vs. tmp@67:5:W\n", "idx": "DRB036"}
{"func": "\n\n\n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf(\"i=%d\\n\",i);\n  return 0;\n} \n", "comment": " \nTwo tasks without synchronization to protect data write, causing data races.\nData race pair: i@58:5:W vs. i@60:5:W\n", "idx": "DRB023"}
{"func": "\n#include <assert.h> \n#include <stdio.h>\n\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n", "comment": " This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Proper user of ordered directive and clause, no data races\n * ", "idx": "DRB110"}
{"func": "\n\n\n\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nvoid foo()\n{\n   a.counter++; \n   a.pcounter++; \n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n", "comment": "\nFor the case of a variable which is not referenced within a construct:\nstatic data member should be shared, unless it is within a threadprivate directive.\n\nDependence pair: a.counter@72:6:W vs. a.counter@72:6:W\n", "idx": "DRB086"}
{"func": "\n\n\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n", "comment": "\nBy utilizing the ordered construct @29 the execution will be\nsequentially consistent. No Data Race Pair.\n", "idx": "DRB155"}
{"func": "\n\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n  }\n  return 0;\n}\n", "comment": "\n * This example is based on fpriv_sections.1.c OpenMP Examples 5.0.0\n * The section construct modifies the value of section_count which breaks the independence of the\n * section constructs. If the same thread executes both the section one will print 1 and the other\n * will print 2. For a same thread execution, there is no data race. \n ", "idx": "DRB126"}
